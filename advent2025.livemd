# Advent 2025

```elixir
Mix.install([
  {:req, "~> 0.5.8"}
],config: [iex: [inspect: [charlists: :as_lists]]])
```

## Introduction

This notebook is my attempt to solve the [Advent of Code 2025](https://adventofcode.com/) challenges.

To run, set the SESSION livebook variable to the value of the session cookie that you find on the advent of code homepage.

[![Run in Livebook](https://livebook.dev/badge/v1/blue.svg)](https://livebook.dev/run?url=https%3A%2F%2Fraw.githubusercontent.com%2Fderhackler%2Fadvent2025%2Frefs%2Fheads%2Fmain%2Fadvent2025.livemd)

## Utils

```elixir
defmodule Input do
  def for_day(day) do
    fname = Path.join(__DIR__,"day#{dayformat(day)}.txt")
    
    if (File.exists?(fname)) do
      File.read!(fname)
    else
      headers = [cookie: "session=" <> System.get_env("LB_SESSION")]
      input = Req.get!("https://adventofcode.com/2025/day/#{day}/input",headers: headers).body
      File.write!(fname,input)
      input
    end
  end

  defp dayformat(day) when day < 10, do: "0#{day}"
  defp dayformat(day), do: "#{day}"
    
end
```

<!-- livebook:{"branch_parent_index":1} -->

## Day 1

```elixir
example = """
L68
L30
R48
L5
R60
L55
L1
L99
R14
L82
"""
```

```elixir
defmodule Day1 do
  def solve(input, :part1) do
    parse(input)
    |> Enum.reduce([50], fn {dir,cnt}, [pos|_rest]=acc -> 
        new_pos = case dir do
          "L" -> rem((pos-cnt)+100, 100)
          "R" -> rem(pos + cnt, 100)
        end

        [new_pos|acc]
      end)
    |> Enum.count(& &1 == 0)
  end

  def solve(input, :part2) do
    parse(input)
    |> Enum.reduce([{50,0}], fn {dir,cnt}, [{pos,_clicks}|_rest]=acc ->     
        {clicks,turns_left} = {div(cnt,100), rem(cnt,100)}
      
        {new_pos,new_clicks} = case dir do
          "L" -> 
            clicks = if pos == 0, do: clicks-1, else: clicks
            {rem((pos-turns_left)+100, 100), (if (pos-turns_left)<=0, do: clicks+1, else: clicks) }
          "R" -> 
            {rem(pos + turns_left, 100), (if (pos+turns_left)>=100, do: clicks+1, else: clicks)}
        end

        [{new_pos,new_clicks}|acc]
      end)
    |> Enum.sum_by(fn {_,clicks} -> clicks end)
  end

  def parse(input) do
    input
    |> String.split("\n", trim: true)
    |> Enum.map(fn <<x,rem::binary>> -> {<<x>>,String.to_integer(rem)} end)
  end
end
```

```elixir
example |> Day1.solve(:part1)
```

```elixir
Input.for_day(1) |> Day1.solve(:part1)
```

```elixir
example |> Day1.solve(:part2)
```

```elixir
Input.for_day(1) |> Day1.solve(:part2)
```

Remarks:

* I don't like my solution. Too long. Too hard to read.
* Maybe change from left-turn special handling to converting into right turn only

<!-- livebook:{"branch_parent_index":1} -->

## Day 2

```elixir
example = "11-22,95-115,998-1012,1188511880-1188511890,222220-222224,1698522-1698528,446443-446449,38593856-38593862,565653-565659,824824821-824824827,2121212118-2121212124"

```

```elixir
defmodule Day2 do
  require Integer
  
  def solve(input, :part1) do
    input 
    |> parse()
    |> Enum.flat_map(fn [min,max] -> 
        Range.new(min,max)
        |> Enum.filter(& is_invalid_part1?/1)
      end)
    |> Enum.sum()
  end

  def solve(input, :part2) do
    input 
    |> parse()
    |> Enum.flat_map(fn [min,max] -> 
        Range.new(min,max)
        |> Enum.filter(& is_invalid_part2?/1)
      end)
    |> Enum.sum()
  end

  def is_invalid_part1?(number) do
    number = Integer.to_string(number)
    half = div(String.length(number), 2)
    {part1,part2} = String.split_at(number,half)
    
    cond do
      Integer.is_odd(String.length(number)) -> false
      part1 == part2 -> true
      :else -> false
    end
  end

  def is_invalid_part2?(number) when number < 10, do: false
  def is_invalid_part2?(number) do
    digits = Integer.digits(number)
    
    repetitions = for chunk_size <- 1..(div(length(digits),2)+1) do
      Enum.chunk_every(digits,chunk_size)
      |> Enum.frequencies()
    end

    Enum.any?(repetitions, fn freq -> 
        case Map.to_list(freq) do
          [{_key,num}] when num >= 2 -> true
          _any -> false
        end
    end
   )
  end

  def parse(input) do
    input
    |> String.split([",","-","\n"], trim: true)
    |> Enum.map(& String.to_integer/1 )
    |> Enum.chunk_every(2)
  end
end
```

```elixir
example |> Day2.solve(:part1)
```

```elixir
Input.for_day(2) |> Day2.solve(:part1)
```

```elixir
example |> Day2.solve(:part2)
```

```elixir
Input.for_day(2) |> Day2.solve(:part2)
```

<!-- livebook:{"branch_parent_index":1} -->

## Day 3

```elixir
example = """
987654321111111
811111111111119
234234234234278
818181911112111
"""
```

* convert to {digit,on,off}

```elixir
defmodule Day3 do
  def solve(input,:part1) do
    input
    |> parse()
    |> Enum.map(& voltage(&1,2))
    |> Enum.sum()
  end

  def solve(input,:part2) do
    input
    |> parse()
    |> Enum.map(& voltage(&1,12))
    |> Enum.sum()    
  end

  def voltage(bank,batteries) do
    bank = bank |> String.to_integer() |> Integer.digits()
    solution = turn_on_highest([],bank,batteries)
    solution |> Enum.join() |> String.to_integer()
  end

  def turn_on_highest(numbers,_,0), do: Enum.reverse(numbers)
  def turn_on_highest(numbers,bankpart,to_turn) do
    left = length(bankpart) # available slots
    max = left - to_turn + 1 # cannot be after this
    {within,remaining} = Enum.split(bankpart,max)

    {maxidx,_idx,val} = Enum.reduce(within,{0,0,0},fn val,{maxidx,idx,max} -> 
      cond do
        val > max -> {idx,idx+1,val}
        :else -> {maxidx,idx+1,max}
      end
    end)

    r2 = Enum.drop(within,maxidx+1)

    turn_on_highest([val|numbers],r2++remaining,to_turn-1)
  end


  def parse(input) do
    input
    |> String.split("\n", trim: true)
  end
end
```

```elixir
example |> Day3.solve(:part1)
```

```elixir
example |> Day3.solve(:part2)
```

```elixir
Input.for_day(3) |> Day3.solve(:part1)
```

```elixir
Input.for_day(3) |> Day3.solve(:part2)
```

<!-- livebook:{"branch_parent_index":1} -->

## Day 4

```elixir
example = """
..@@.@@@@.
@@@.@.@.@@
@@@@@.@.@@
@.@@@@..@.
@@.@@@@.@@
.@@@@@@@.@
.@.@.@.@@@
@.@@@.@@@@
.@@@@@@@@.
@.@.@@@.@.
"""
```

```elixir
defmodule Grid do
  defstruct [:cells]

  def new(cells) do
    # cells: [{{x,y},val}]
    %Grid{cells: Enum.into(cells,%{})}
  end

  def adjacent(grid = %Grid{}, {x,y}) do
    # returns the coordinate as well as the cell value
    shift_x = [-1,0,1]
    shift_y = [-1,0,1]

    for sx <- shift_x, sy <- shift_y, {sx,sy} != {0,0}, reduce: [] do
      acc -> 
        case Map.get(grid.cells, {x+sx,y+sy}, nil) do
          nil -> acc
          val -> [{{sx,sy}, val} | acc]
        end
    end
  end

  def drop(grid = %Grid{}, cells) do
    # let's ignore the bug that the size can change...
    %Grid{grid | cells: Map.drop(grid.cells, cells)}
  end

end
```

```elixir
defmodule Day4 do
  def solve(input, :part1) do
    grid = input |> parse()

    grid.cells
    |> Enum.filter(fn {_xy,val} -> val == ?@ end)
    |> Enum.filter(fn {xy,_val} -> adjacent_rolls_count(grid,xy) < 4 end)
    |> Enum.count()
  end

  def solve(input, :part2) do
    grid = input |> parse()
    recursive_remove(grid,true,0)
  end

  def recursive_remove(_grid,false,cnt), do: cnt
  def recursive_remove(grid,true,cnt) do
    to_remove = grid.cells
    |> Enum.filter(fn {_xy,val} -> val == ?@ end)
    |> Enum.filter(fn {xy,_val} -> adjacent_rolls_count(grid,xy) < 4 end)
    |> Enum.map(fn {xy,_val} -> xy end)

    new_grid = Grid.drop(grid, to_remove)

    recursive_remove(new_grid,to_remove != [], cnt + length(to_remove))
  end

  def adjacent_rolls_count(grid,{x,y}) do
    Grid.adjacent(grid,{x,y})
    |> Enum.filter(fn {_xy,val} -> val == ?@ end)
    |> Enum.count()
  end
  
  
  def parse(input) do
    input |> to_grid({0,0}, [])
  end

  def to_grid("",_xy,cells), do: Grid.new(Enum.reverse(cells))
  def to_grid(<<"\n",rem::binary>>,{_x,y},cells), do: to_grid(rem,{0,y+1},cells)
  def to_grid(<<char,rem::binary>>,{x,y},cells) do
    to_grid(rem,{x+1,y},[{{x,y},char}|cells])
  end
end
```

```elixir
example |> Day4.solve(:part1)
```

```elixir
example |> Day4.solve(:part2)
```

```elixir
Input.for_day(4) |> Day4.solve(:part1)
```

```elixir
Input.for_day(4) |> Day4.solve(:part2)
```

```elixir
defmodule Day4Alternative do

  def solve(input, :part2) do
    grid = input |> parse()

    # get a map with only the neighbors count
    grid = grid.cells
      |> Enum.filter(fn {_xy,val} -> val == ?@ end)
      |> Enum.map(fn {xy,_val} -> {xy,adjacent_rolls_count(grid,xy)} end)
      |> Enum.into(%{})

    newgrid = remove(grid)

    Enum.count(grid) - Enum.count(newgrid)
  end

  def remove(grid) do
    sorted = Enum.sort_by(grid, fn {{x,y},_} -> {x,y} end)
    
    newgrid = Enum.reduce(sorted, grid, fn {xy,_}, acc -> 
      case Map.get(acc,xy) do
        nil -> acc # the cell does not exist anymore
        val when val < 4 -> drop_and_decrement(acc,xy) # we can remove it
        _else -> acc # can't do anything
      end
    end)

    if Enum.count(grid) == Enum.count(newgrid) do
      newgrid
    else
      remove(newgrid)
    end
  end

  def drop_and_decrement(grid,{x,y} = _to_drop) do
    # returns the coordinate as well as the cell value
    shift_x = [-1,0,1]
    shift_y = [-1,0,1]

    for sx <- shift_x, sy <- shift_y, {sx,sy} != {0,0}, reduce: Map.delete(grid,{x,y}) do
      grid -> 
        adj_xy = {x+sx,y+sy}
        case Map.get(grid,adj_xy) do
          nil -> grid
          val when val-1 < 4 -> drop_and_decrement(grid,adj_xy)
          val -> Map.put(grid,adj_xy,val-1)
        end
    end
  end

  def adjacent_rolls_count(grid,{x,y}) do
    Grid.adjacent(grid,{x,y})
    |> Enum.filter(fn 
      {_xy,nil} -> false
      {_xy,?@} -> true
      _ -> false
        end)
    |> Enum.count()
  end
  
  def parse(input) do
    input |> to_grid({0,0}, [])
  end

  def to_grid("",_xy,cells), do: Grid.new(Enum.reverse(cells))
  def to_grid(<<"\n",rem::binary>>,{_x,y},cells), do: to_grid(rem,{0,y+1},cells)
  def to_grid(<<char,rem::binary>>,{x,y},cells) do
    to_grid(rem,{x+1,y},[{{x,y},char}|cells])
  end
end
```

```elixir
example |> Day4Alternative.solve(:part2)
```

```elixir
Input.for_day(4) |> Day4Alternative.solve(:part2)
```

<!-- livebook:{"branch_parent_index":1} -->

## Day 5

```elixir
example = """
3-5
10-14
16-20
12-18

1
5
8
11
17
32
"""
```

```elixir
defmodule Day5 do
  def solve(input,:part1) do
    {fresh_ingredient_ranges,ingredients} = parse(input)
    ranges = sort_ranges(fresh_ingredient_ranges)    

    fresh = for i <- ingredients do
      Enum.reduce_while(ranges, false, fn r,_acc -> 
          case Enum.member?(r,i) do
            true -> {:halt, true}
            false -> {:cont, false}
          end
        end)
    end

    Enum.

    Enum.sum_by(fresh,fn 
      true -> 1
      false -> 0 
    end)
  end

  def solve(input, :part2) do
    {ranges,_ingredients} = parse(input)
    
    ranges = ranges |> Enum.sort_by(fn [min,_max] -> min end)
    
    {_,cnt} = Enum.reduce(ranges,{0,0},fn [min,max],{last_counted,count} ->
        cond do
          min > last_counted -> {max, count + (max - min) + 1} # distinct
          min <= last_counted && max > last_counted -> {max, count + (max - last_counted)} # overlapping
          :else -> {last_counted, count} # containing
        end
      end)

    cnt
  end

  

  def sort_ranges(ranges) do
    ranges
    |> Enum.sort_by(fn [min,_max] -> min end)
    |> Enum.map(fn [min,max] -> Range.new(min,max) end)
  end

  def parse(input) do
    [ranges,ingredients] = String.split(input,"\n\n",trim: true)
    ranges = String.split(ranges, ["-","\n"],trim: true) 
      |> Enum.map(& String.to_integer/1)
      |> Enum.chunk_every(2)
    ingredients = String.split(ingredients,"\n",trim: true)
      |> Enum.map(& String.to_integer/1)
    {ranges,ingredients}
  end
end
```

```elixir
example |> Day5.solve(:part1)
```

```elixir
Input.for_day(5) |> Day5.solve(:part1)
```

```elixir
import ExUnit.Assertions

tests =[
  ["1-3\n\n0", 3], # alone
  ["1-3\n1-3\n\n0", 3], # full overlap
  ["1-3\n2-5\n\n0", 5], # partial overlap
  ["1-3\n3-5\n\n0", 5], # last digit overlap
  ["1-3\n5-5\n\n0", 4], # no overlap
  ["1-5\n2-3\n\n0", 5], # fully contained
]

tests
|> Enum.each(fn [input,expected] -> 
    sol = Day5.solve(input,:part2)
    assert expected == sol, "expected #{expected} got #{sol}. Input: \n#{input} "
  end)
```

```elixir
Input.for_day(5) |> Day5.solve(:part2)
```

```elixir
example |> Day5.solve(:part2)
```
